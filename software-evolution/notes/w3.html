<lecture-notes-title
    title="Reverse Engineering"
    lecturer="Vadim Zaytsev"
    week="3"
    date="2015-11-09"></lecture-notes-title>

<p>
  Reverse engineering is used to detect design. Reverse engineering requirements gives more confidence and shows
  business rules.
</p>

<p>
  In the lanes of slide 3, refactoring goes back to architecture, when it is not it is just cleanup. Bugs tend to go
  everywhere.
</p>

<h2>Code reverse engineering</h2>

<p>Techniques</p>

<ul>
  <li>Parsing: Recognising Structure</li>
  <li>Fact Extraction: Parsing + fact base</li>
  <li>Slicing</li>
  <li>Pattern Matching</li>
  <li>Decomposition</li>
  <li>Exploration</li>
</ul>

<p>Comments</p>
<ul>
  <li>With slicing you remove unnecessary code. You can find cohesion.</li>
  <li>Pattern matching visits a structure and acts when the pattern holds</li>
  <li>Decomposition is an NP hard problem. Only possible with brute force.</li>
  <li>Exploration: Find what you looking for and omit all the rest.</li>
</ul>

<h2>Data Reverse Engineering</h2>

<p>WEKA - TODO lookup</p>

<p>Goals</p>

<ul>
  <li>Database design recovery</li>
  <li>Pattern recognition</li>
  <li>Information retrieval</li>
  <li>Clustering</li>
  <li>Mining unstructured data</li>
</ul>
