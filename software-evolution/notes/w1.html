<lecture-notes-title
    title="Introduction to Software Evolution"
    lecturer="Vadim Zaytsev"
    week="1"
    date="2015-10-26"></lecture-notes-title>

<p>
  The slides to this lecture can be found <a href="software-evolution/resources/lectures/lecture1 - Introduction.pdf">here</a>.
</p>
<h3>Setup</h3>
<h5>Why Study Software Evolution</h5>

<ul>
  <li>Learn from past</li>
  <li>Reason about made choices</li>
  <li>Reason about the effect of evolution.</li>
</ul>

<h5>What will you do in this course</h5>

<p>Learn how to analyze software and write tooling to do this.</p>

<ul>
  <li>Write metrics</li>
  <li>Code clone detection software</li>
  <li>Write essay</li>
</ul>

<p>There is a honours track, but without a bonus.</p>

<h3>Software Types
  <small>Slide 12</small>
</h3>

<p>There are 3 types of software</p>

<ul>
  <li>Most software are E-type</li>
  <li>Types are scope related.</li>
</ul>
<h5>S-type (specification)</h5>

<ul>
  <li>software-testing knowledge</li>
  <li>Know all information. Problem is commonly known. Allows:
    <ul>
      <li>Pre- and postcondition</li>
      <li>Automated testing</li>
    </ul>
  </li>
  <li>Software <strong>does not evolve</strong></li>
</ul>

<p>Example of such software is a sorting algorithm.</p>

<h5>P-type (problem solving)</h5>

<ul>
  <li>Models to the real world (imperfectly)</li>
  <li>Can be outperformed</li>
  <li>Qualitative acceptance</li>
  <li>Requirements or abstract of the world changes.</li>
  <li>Can <strong>evolve continuously</strong></li>
</ul>

<p>Example: Chess, Siri, climate prediction</p>

<h5>E-type (embedded)</h5>

<p>Embedded implies embedded in the real world.</p>

<ul>
  <li>Solution is part of the world (a product)</li>
  <li>Acceptance is subjective</li>
  <li>Inherently evolving</li>
</ul>

<p>Example: Facebook</p>

<h3>Lehman's Laws</h3>

<p>Laws are needed because the software world is not real.</p>

<ol>
  <li>Continuing Change
    <ul>
      <li>E-type systems rot when not changed</li>
    </ul>
  </li>
  <li>Increasing Complexity
    <ul>
      <li>Evolving results in complexity</li>
      <li>E-type systems tend to be more complex</li>
    </ul>
  </li>
  <li>Self-regulating
    <ul>
      <li>TODO</li>
    </ul>
  </li>
  <li>
    Invariant Work Rate
    <ul>
      <li>Development activity is invariant.</li>
      <li>Speed of change is constant (based on equal resources).</li>
    </ul>
  </li>
  <li>
    Conservation of Familiarity
    <ul>
      <li>E-system changes per release</li>
      <li>Never too little or too much</li>
    </ul>
  </li>
  <li>
    Continuing Growth
    <ul>
      <li>Add features too keep users happy</li>
      <li>Expectation Creep</li>
    </ul>
  </li>
  <li>
    Declining Quality
    <ul>
      <li>The perceived quality will change when it exists longer</li>
    </ul>
  </li>
  <li>
    Feedback System
    <ul>
      <li>multi-level: hardware/environment changes</li>
      <li>multi-loop: different implementations/releases</li>
      <li>multi-agent: developers change</li>
    </ul>
  </li>
</ol>


<h3>Maintenance Types</h3>
<p>The modification of software products after delivery</p>
<ul>
  <li>to correct faults</li>
  <li>to improve performance or other attributes</li>
  <li>or to adapt the product to a modified environment</li>
</ul>

<strong>Types</strong>
<ul>
  <li>Corrective: bugs</li>
  <li>Adaptive: environment</li>
  <li>Perfective: performance, nice refactoring</li>
  <li>Preventive: to top competitors</li>
</ul>

<p>(slide 33) percentage is over 100% of commits. Study from 1980.</p>

<h3>Top 5 problems</h3>

<p>See slide 35.</p>

