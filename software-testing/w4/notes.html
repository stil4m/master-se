<lecture-notes-title
    title="Functional Programming and Imperative Programming"
    lecturer="Jan van Eijck"
    week="4"
    date="2015-09-21"></lecture-notes-title>

<h4>Question Session</h4>

<p>
  <strong>How do we know that we have tested enough?</strong>
</p>

<p>
  <i>We can never verify our program, we can only falsify it.
    When we are not able to falsify is, it does not mean we have verified it.</i>
</p>

<h4>4 Ingredients of imperative programming</h4>

<ol>
  <li>Variable Assignment: <code>&lt;var&gt; := &lt;expr&gt;</code></li>
  <li>Conditional Execution: <code>if &lt;bexpr&gt; then &lt;statement1&gt; else &lt;statement2&gt;</code></li>
  <li>Sequential Composition: <code>&lt;statement1&gt; ; &lt;statement2&gt;</code></li>
  <li>Iteration: <code>while &lt;expr&gt; do &lt;statement&gt;</code></li>
</ol>

<h4>Recursion</h4>

Read: Recursion on the second argument is easier for the compiler

<h4>Fixed Point</h4>

Fixed point removed the recursion from a procedure.

<h4>History of programming</h4>
<pre>
             Turing                           Church
              |                                 |
Von Neumann  Turing Machine                   Lambda Calculus     Milner
        \     |                                 |                 /
          ---Imperitive Programming           Functional Languages
              |
             Stored Program Computation
</pre>
