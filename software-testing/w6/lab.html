<h1>Lab 6 Software Specification and Testing</h1>

<h4>1. Implement expM</h4>

<p>
  We did this exercise on our own and I used a reference from
  <a href="https://www.khanacademy.org/computing/computer-science/cryptography/modarithmetic/a/modular-exponentiation">Khan Academy</a>.
  Jasper and me solved it, but Jasper his implementation was more nicer. Although I refactored my implementation, we took
  his.
</p>

<h4>2. Test the performance of <code>exM</code> and <code>expM</code></h4>

<p>
  <i>Performed by Nikki and Paco</i>
</p>

<h4>3. Write a function that generates composite numbers
  <small>Together with Jasper</small>
</h4>

<p>
  Pretty easy with the assumption that we could use the generation of prime numbers.
</p>

<h4>4. Least number that fails Fermat's primality check
  <small>Together with Jasper</small>
</h4>

<p>Is 4 and will always be 4 depending on the repetition and the value of <code>k</code>.</p>

<h4>5. What do you find when you test carmicheal numbers with the Fermat primality check</h4>

<p>
  <i>Performed by Jasper</i>
</p>

<h4>6. Use Miller-Rabin to test the carmicheal What do you find when you test carmicheal numbers with the Fermat primality check</h4>

<p>
  Performed by me. It was quite easy to see that the test of Miller-Rabin was much more eficient.
</p>

<h4>6. Use Miller-Rabin to generate large Mersenne primes</h4>

<p>
  Easy implementation that uses a stream of low primes to generate larger primes.
</p>


<h4>7. Generate a pair of large primes to create a public and private key
  <small>Together with Jasper</small>
</h4>

<p>
  Easy implementation. Interesting note was that the least significant bit should be 1 to create a uneven number.
</p>
