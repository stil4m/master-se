<h1>Personal Reading: Test Driven Development</h1>

<p>
  As this week reading assignment topic I have chosen Test Driven Development (TDD) due to two reasons. First is was one
  of the suggested topics and secondly because I have some experienced from when I applied it in a 6 month project and
  wanted to reference these experienced to scientific research. As source material for this topic I used the 'Making
  Software' book and the paper 'A structured experiment of test-driven development'. The book mainly elaborated on the
  definition of TDD and presents an empirical study. The paper presents a small scale empirical study and a survey on
  the experience on practicing TDD.
</p>

<h2>What is Test Driven Development</h2>

<p>
  As the Making Software book presents, TDD is a software development practice where a repetition of steps should lead
  robust code. These steps are [TODO REF]:
</p>

<ol>
  <li>Choose a small task.</li>
  <li>Write a test for that task.</li>
  <li>Run all the tests to verify that the new test fails.</li>
  <li>Write minimal production code to complete the task.</li>
  <li>Run all tests (including the new one) to verify that they pass.</li>
  <li>Refactor the code as necessary.</li>
</ol>

<h2>Merits and drawbacks</h2>

<p>
  As all the things in life, also TDD has it's merits and drawbacks. The main advantages that the literature presents
  as arguments in favor for this method are: better external quality [TODO Book and paper]; TDD utilizes the
  understanding of code and thus helps to manage complexity [TODO paper]; creates test assets that utilize (automated)
  regression testing [TODO paper and book]; decreases the chance of defect injection [TODO paper].
</p>

<p>
  Some of these arguments are are presented clearly with scientific foundation, such as the increase of external quality
  when TDD is applied. This effect is pretty straightforward when you study the definition that 1) all new code is
  tested while you are not allowed to write more code than needed (point 4 in the definition) 2) the new code does not
  break the existing implementation (point 5 in the definition) and 3) the implementation is always feature centric.
  This implies that by definition it is impossible to introduce code that degrades the external quality, because all
  code is introduced intentionally by the developer as he realizes requirements. This statement is verified by the
  advantage that the defect injection chance is decreased.<br>
  A what I find more obscure advantage is the statement that TDD utilizes the understanding and management of
  complexity. Firstly, this point is not verified with scientific proof in the researched paper. Secondly as the [TODO
  Paper] addressed and the book lacks to do, using TDD does not lead to formal documentation (while the test is your
  documentation). The alternative to documentation in TDD are the produced tests, however the required information may
  not be presented to the reader in a glance. For example:
</p>

<blockquote>
  Suppose there is a functionality `A` with the specification 'When a number is entered between 1 and 10, multiply it by
  2 otherwise throw an exception. Using TDD this will result in at least 3 tests: testing a valid number; testing a
  number beneath 1; and testing a number above 10. When a developer has to search for the specification based on the
  tests he has to look into the details of 3 tests, which possibly will not fit into one developer console due to
  programming language syntactics. Instead a simple comment above the implementing code or a formal requirement may be
  more helpful to the developer.
</blockquote>

<p>
  The above example is rather small and in my opinion will cause more problems when functionality grows when there is a
  lack of documentation. The reference implementation I got for this problem is an algorithm for medical images to
  transform a 16-bit gray-scale image to a 8-bit gray-scale image with additional parameters to shift the domain and the
  window on the image. The tests written using TDD were created when I knew the domain and the requirements of the
  algorithm. However when you open the test code at this moment it is not possible to figure out what the specification
  was. The point here is that you can not assume that the test code is a replacement for formal documentation.
</p>

